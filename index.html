<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å»ºç­‘å¯¼è§ˆç³»ç»Ÿ - æ–°åŒºç»¼åˆæ•™å­¦æ¥¼B</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"}}</script>
  <style>
    body{margin:0;overflow:hidden;font-family:system-ui,-apple-system,sans-serif}
    .loading-spinner{border:4px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;width:48px;height:48px;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .room-label{position:absolute;background:rgba(255,255,255,0.95);padding:4px 8px;border-radius:6px;font-size:11px;pointer-events:none;white-space:nowrap;transform:translate(-50%,-50%);box-shadow:0 2px 4px rgba(0,0,0,0.1);border:1px solid #e2e8f0;display:flex;align-items:center;gap:4px}
    .room-label .icon{font-size:14px}
    .room-label .content{display:flex;flex-direction:column;line-height:1.2}
    .room-label .num{color:#2563eb;font-weight:700;font-size:10px}
    .room-label .name{color:#334155;font-weight:500}
  </style>
</head>
<body class="bg-slate-100">
  <div id="loading" class="fixed inset-0 bg-white z-50 flex items-center justify-center">
    <div class="text-center"><div class="loading-spinner mx-auto mb-4"></div><p class="text-slate-600">æ­£åœ¨åŠ è½½å»ºç­‘æ•°æ®...</p></div>
  </div>

  <div id="canvas-container" class="w-full h-screen relative">
    <!-- é¡¶éƒ¨æœç´¢æ  -->
    <div class="absolute top-4 left-4 right-20 z-20 flex gap-3">
      <div class="flex-1 max-w-md relative">
        <input type="text" id="search-input" placeholder="æœç´¢æˆ¿é—´ç¼–å·æˆ–åç§°..." 
          class="w-full px-4 py-3 pl-10 bg-white/95 backdrop-blur rounded-xl shadow-lg border border-slate-200 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
        <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
        </svg>
        <!-- æœç´¢ç»“æœä¸‹æ‹‰ -->
        <div id="search-results" class="hidden absolute top-full left-0 right-0 mt-2 bg-white rounded-xl shadow-xl border border-slate-200 max-h-80 overflow-y-auto">
        </div>
      </div>
      <div class="bg-white/95 backdrop-blur px-4 py-2 rounded-xl shadow-lg border border-slate-200 flex items-center gap-2">
        <span class="text-blue-600 font-bold" id="room-count">--</span>
        <span class="text-slate-400 text-sm" id="info-count"></span>
      </div>
    </div>

    <!-- ç›¸æœºè°ƒè¯•é¢æ¿ï¼ˆé»˜è®¤éšè—ï¼‰ -->
    <div id="camera-debug" class="hidden absolute top-4 right-20 z-20 bg-black/70 text-green-400 text-xs font-mono px-3 py-2 rounded-lg">
      <div>Pos: <span id="cam-pos">--</span></div>
      <div>Target: <span id="cam-target">--</span></div>
      <div>Dist: <span id="cam-dist">--</span></div>
    </div>

    <!-- å³ä¾§æ¥¼å±‚é€‰æ‹©å™¨ -->
    <div class="absolute right-4 top-1/2 -translate-y-1/2 z-20 flex flex-col gap-1">
      <button data-floor="all" class="floor-btn active w-12 h-12 text-xs font-bold rounded-lg bg-blue-600 text-white shadow-lg hover:scale-105 transition-transform">ALL</button>
      <button data-floor="6" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">6F</button>
      <button data-floor="5" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">5F</button>
      <button data-floor="4" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">4F</button>
      <button data-floor="3" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">3F</button>
      <button data-floor="2" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">2F</button>
      <button data-floor="1" class="floor-btn w-12 h-10 text-xs font-bold rounded-lg bg-white/90 text-slate-600 shadow-lg hover:bg-blue-100 hover:scale-105 transition-transform">1F</button>
    </div>

    <!-- é€‰ä¸­ä¿¡æ¯é¢æ¿ -->
    <div id="selected-info" class="hidden absolute bottom-4 left-4 z-20 bg-white/95 backdrop-blur p-4 rounded-xl shadow-xl border border-amber-200 max-w-sm">
      <div class="flex items-start justify-between">
        <div>
          <div id="selected-name" class="text-lg font-bold text-slate-800"></div>
          <div id="selected-details" class="mt-1 text-sm text-slate-600"></div>
        </div>
        <button id="close-selected" class="text-slate-400 hover:text-slate-600 text-xl leading-none">&times;</button>
      </div>
    </div>

    <!-- æ‚¬æµ®æç¤º -->
    <div id="tooltip" class="fixed hidden bg-white/95 backdrop-blur px-4 py-3 rounded-xl shadow-2xl border border-slate-200 min-w-[200px] z-30 pointer-events-none">
      <div id="tooltip-header" class="text-base font-bold text-slate-800 mb-1"></div>
      <div id="tooltip-body" class="text-sm text-slate-600"></div>
    </div>

    <!-- æ¥¼å±‚æŒ‡ç¤ºå™¨ -->
    <div id="floor-indicator" class="absolute bottom-6 left-1/2 -translate-x-1/2 text-8xl font-bold text-slate-300 pointer-events-none select-none" style="-webkit-text-stroke: 2px rgba(100,116,139,0.3); text-shadow: 0 2px 10px rgba(0,0,0,0.1);">ALL</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    const ROOM_COLORS = {
      'åŠå…¬': 0x7dd3fc, 'æ•™å®¤': 0x86efac, 'å®éªŒ': 0xc4b5fd, 'æœåŠ¡': 0xfda4af,
      'å«ç”Ÿ': 0xd1d5db, 'æ¥¼æ¢¯': 0xfcd34d, 'è®¾å¤‡': 0xfdba74, 'æœºæˆ¿': 0x67e8f9, 'default': 0xa5b4fc
    };
    
    const ROOM_ICONS = {
      'åŠå…¬': 'ğŸ’¼', 'æ•™å®¤': 'ğŸ‘¨â€ğŸ«', 'å®éªŒ': 'ğŸ§ª', 'æœåŠ¡': 'â˜•',
      'å«ç”Ÿ': 'ğŸš»', 'æ¥¼æ¢¯': 'ğŸªœ', 'ç”µæ¢¯': 'ğŸ›—', 'è®¾å¤‡': 'âš™ï¸', 
      'æœºæˆ¿': 'ğŸ’»', 'ä¼šè®®': 'ğŸ¤', 'åº“æˆ¿': 'ğŸ“¦', 'default': 'ğŸšª'
    };

    // æœç´¢ç›¸å…³
    let allRoomsIndex = []; // å­˜å‚¨æ‰€æœ‰æˆ¿é—´çš„æœç´¢ç´¢å¼• {floorNum, room, mesh}

    function parseRoomInfo(text) {
      let clean = text.replace(/\{\\f[^;]*;/g,'').replace(/\\f[^;]*;/g,'').replace(/\}/g,'').replace(/\{/g,'')
        .replace(/\\P/g,'\n').replace(/\\p[^;]*;/g,'').replace(/\\[A-Za-z]/g,' ').trim();
      const info = {};
      // åŒ¹é…æˆ¿é—´ç¼–å·
      let m = clean.match(/æˆ¿é—´ç¼–å·[ï¼š:]\s*(\S+)/); if (m) info.roomNumber = m[1].trim();
      // åŒ¹é…æˆ¿é—´åç§°ï¼ˆä¸¤ç§æ ¼å¼ï¼‰
      m = clean.match(/æˆ¿é—´åç§°[ï¼š:]\s*([^\n]+)/); if (m) info.roomName = m[1].trim();
      if (!info.roomName) { m = clean.match(/åç§°[ï¼š:]\s*([^\n]+)/); if (m) info.roomName = m[1].trim(); }
      // åŒ¹é…æˆ¿é—´å±æ€§
      m = clean.match(/æˆ¿é—´å±æ€§[ï¼š:]\s*([^\n]+)/); if (m) info.roomType = m[1].trim();
      // åŒ¹é…é¢ç§¯
      m = clean.match(/ä½¿ç”¨é¢ç§¯[ï¼š:]\s*([\d.]+)/); if (m) info.usableArea = m[1].trim() + ' ã¡';
      m = clean.match(/å»ºç­‘é¢ç§¯[ï¼š:]\s*([\d.]+)/); if (m) info.buildingArea = m[1].trim() + ' ã¡';
      // åŒ¹é…äººå‘˜
      m = clean.match(/ä½¿ç”¨äººå‘˜[ï¼š:]\s*([^\n]*)/); if (m && m[1].trim()) info.users = m[1].trim();
      m = clean.match(/ç®¡ç†äººå‘˜[ï¼š:]\s*([^\n]+)/); if (m) info.manager = m[1].trim();
      // åŒ¹é…éƒ¨é—¨
      m = clean.match(/[ï¼ˆ(]([^ï¼‰)]+å­¦é™¢|ä¸­å¿ƒ)[ï¼‰)]/); if (m) info.department = m[1].trim();
      return Object.keys(info).length ? info : null;
    }

    function parseDXF(text) {
      const rooms = [], fallbackRooms = [], labels = [], lines = text.split('\n').map(l => l.trim());
      let roomId = 0;
      for (let i = 0; i < lines.length; i++) {
        if (lines[i] === 'LWPOLYLINE') {
          let layer = '', closed = false, points = [], j = i + 1;
          while (j < lines.length && lines[j] !== '0') {
            const code = parseInt(lines[j]), val = lines[j + 1];
            if (code === 8) layer = val;
            else if (code === 70) closed = (parseInt(val) & 1) === 1;
            else if (code === 10) {
              const x = parseFloat(val);
              let k = j + 2;
              while (k < lines.length && parseInt(lines[k]) !== 20) k += 2;
              if (k < lines.length) points.push({ x, y: parseFloat(lines[k + 1]) });
            }
            j += 2; if (lines[j] === '0') break;
          }
          
          if (closed && points.length >= 3) {
            const cx = points.reduce((s,p) => s+p.x, 0) / points.length;
            const cy = points.reduce((s,p) => s+p.y, 0) / points.length;
            
            // è®¡ç®—é¢ç§¯
            const area = Math.abs(points.reduce((sum, p, i, arr) => {
              const next = arr[(i + 1) % arr.length];
              return sum + (p.x * next.y - next.x * p.y);
            }, 0) / 2);

            // è¿‡æ»¤æ‰æå°çš„åŒºåŸŸï¼ˆå¯èƒ½æ˜¯æŸ±å­æˆ–æ‚ç‰©ï¼Œ<2å¹³ç±³ï¼‰å’Œæå¤§çš„åŒºåŸŸï¼ˆå¯èƒ½æ˜¯å›¾æ¡†ï¼Œ>5000000000ï¼‰
            if (area > 2000000 && area < 5000000000) {
              const room = { id: roomId++, points, center: {x:cx, y:cy}, info: null, area };
              if (layer === 'ä½¿ç”¨é¢ç§¯çº¿') {
                rooms.push(room);
              } else {
                fallbackRooms.push(room);
              }
            }
          }
          i = j - 1;
        } else if (lines[i] === 'MTEXT') {
          let layer = '', x = 0, y = 0, textParts = [], j = i + 1;
          while (j < lines.length && lines[j] !== '0') {
            const code = parseInt(lines[j]), val = lines[j + 1];
            if (code === 8) layer = val;
            else if (code === 10) x = parseFloat(val);
            else if (code === 20) y = parseFloat(val);
            else if (code === 3 || code === 1) textParts.push(val || '');
            j += 2;
          }
          const fullText = textParts.join('');
          // åŒ¹é…åŒ…å«æˆ¿é—´ä¿¡æ¯çš„æ–‡æœ¬
          if (layer === 'æ–‡å­—' && (fullText.includes('æˆ¿é—´ç¼–å·') || fullText.includes('åç§°ï¼š') || fullText.includes('åç§°:'))) {
            const info = parseRoomInfo(fullText);
            if (info) labels.push({ x, y, info });
          }
          i = j - 1;
        }
      }
      // ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
      function pointInPolygon(x, y, pts) {
        let inside = false;
        for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
          const xi = pts[i].x, yi = pts[i].y, xj = pts[j].x, yj = pts[j].y;
          if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        return inside;
      }
      
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†å›¾å±‚çš„æˆ¿é—´ï¼Œä½¿ç”¨å¤‡ç”¨æˆ¿é—´ï¼ˆä¸»è¦ç”¨äºé¡¶å±‚ï¼‰
      const finalRooms = rooms.length > 0 ? rooms : fallbackRooms;
      
      labels.forEach(label => {
        let best = null, minDist = Infinity;
        // é¦–å…ˆå°è¯•æ‰¾åŒ…å«è¯¥ç‚¹çš„æˆ¿é—´
        for (const room of finalRooms) {
          if (pointInPolygon(label.x, label.y, room.points)) {
            best = room;
            minDist = 0;
            break;
          }
        }
        // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œç”¨è·ç¦»åŒ¹é…ï¼ˆå¢å¤§é˜ˆå€¼ï¼‰
        if (!best) {
          for (const room of finalRooms) {
            const dist = Math.hypot(label.x - room.center.x, label.y - room.center.y);
            if (dist < minDist) { minDist = dist; best = room; }
          }
        }
        if (best && minDist < 100000) best.info = label.info;
      });
      
      // è®¡ç®—æ¯ä¸ªæˆ¿é—´çš„é¢ç§¯ï¼Œæ‰¾å‡ºæœ€å¤§çš„æ— ä¿¡æ¯åŒºåŸŸå‘½åä¸ºèµ°å»Š
      let maxAreaRoom = null, maxArea = 0;
      finalRooms.forEach(room => {
        // area å·²ç»åœ¨ä¸Šé¢è®¡ç®—è¿‡äº†
        if (!room.info && room.area > maxArea) {
          maxArea = room.area;
          maxAreaRoom = room;
        }
      });
      // å°†é¢ç§¯æœ€å¤§çš„æ— ä¿¡æ¯åŒºåŸŸæ ‡è®°ä¸ºèµ°å»Š
      if (maxAreaRoom) {
        maxAreaRoom.info = { roomName: 'èµ°å»Š', usableArea: (maxArea / 1000000).toFixed(2) + ' ã¡' };
        maxAreaRoom.isCorridor = true;
      }
      
      return finalRooms;
    }

    function getRoomColor(info) {
      if (!info) return ROOM_COLORS.default;
      const text = ((info.roomType||'') + (info.roomName||'')).toLowerCase();
      for (const [t,c] of Object.entries(ROOM_COLORS)) if (t !== 'default' && text.includes(t)) return c;
      return ROOM_COLORS.default;
    }

    function getRoomIcon(info) {
      if (!info) return ROOM_ICONS.default;
      const text = ((info.roomType||'') + (info.roomName||'')).toLowerCase();
      for (const [t,i] of Object.entries(ROOM_ICONS)) if (t !== 'default' && text.includes(t)) return i;
      return ROOM_ICONS.default;
    }

    // åˆ¤æ–­æ˜¯å¦ä¸ºèµ°å»Š/å…¬å…±åŒºåŸŸï¼ˆéœ€è¦é™ä½é«˜åº¦å’Œé€æ˜åŒ–ï¼‰
    function isCorridor(room) {
      // å·²ç»åœ¨è§£ææ—¶æ ‡è®°çš„èµ°å»Š
      if (room.isCorridor) return true;
      if (!room.info) return false;
      const text = ((room.info.roomType||'') + (room.info.roomName||'')).toLowerCase();
      return text.includes('èµ°å»Š') || text.includes('è¿‡é“') || text.includes('é€šé“') || text.includes('é—¨å…') || text.includes('å¤§å…');
    }
    
    // åˆ¤æ–­æ˜¯å¦ä¸ºæ¥¼æ¢¯é—´/ç”µæ¢¯å…ï¼ˆç‰¹æ®Šæ ·å¼ï¼‰
    function isStairOrElevator(room) {
      if (!room.info) return false;
      const text = ((room.info.roomType||'') + (room.info.roomName||'')).toLowerCase();
      return text.includes('æ¥¼æ¢¯') || text.includes('ç”µæ¢¯');
    }

    const FLOOR_NAMES = { 1: '1F', 2: '2F', 3: '3F', 4: '4F', 5: '5F', 6: '6F' };
    const FLOOR_COUNT = 6;
    const FLOOR_HEIGHT = 8; // æ¯å±‚æ¥¼ä¹‹é—´çš„é—´è·
    
    let currentView = 'all'; // 'all' æˆ– æ¥¼å±‚æ•°å­—
    let scene, camera, renderer, labelRenderer, controls;
    let floorGroups = {}; // å­˜å‚¨æ¯å±‚çš„3Dç»„
    let allFloorsData = {}; // å­˜å‚¨æ¯å±‚çš„è§£ææ•°æ®
    let roomMeshes = [];
    let hoveredMesh = null, selectedMesh = null;
    const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
    
    // ç›¸æœºåŠ¨ç”»ç›¸å…³
    let cameraTargetPos = null, cameraTargetLookAt = null;
    const cameraAnimSpeed = 0.08;
    
    // é€æ˜åº¦åŠ¨ç”»ç›¸å…³
    let fadeAnimations = []; // { meshes, targetOpacity, speed }

    // è§£æå•ä¸ªæ¥¼å±‚çš„DXF
    async function parseFloorDXF(floorNum) {
      const res = await fetch(`floor${floorNum}.dxf`);
      const dxfText = await res.text();
      return parseDXF(dxfText);
    }

    // åˆ›å»ºæ¥¼å±‚çš„3Då¯¹è±¡
    function createFloorMeshes(rooms, floorNum, zOffset, showLabels = true) {
      const group = new THREE.Group();
      group.userData.floorNum = floorNum;
      
      // è®¡ç®—è¯¥æ¥¼å±‚è‡ªå·±çš„åæ ‡èŒƒå›´
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      rooms.forEach(r => r.points.forEach(p => {
        minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y);
      }));
      const width = maxX - minX, height = maxY - minY;
      const localScale = 50 / Math.max(width, height);
      const localOffsetX = minX + width / 2;
      const localOffsetY = minY + height / 2;
      
      // åœ°æ¿
      const floorGeo = new THREE.PlaneGeometry(width * localScale * 1.1, height * localScale * 1.1);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0xf1f5f9, side: THREE.DoubleSide });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.position.z = -0.1;
      floor.receiveShadow = true;
      group.add(floor);
      
      const meshes = [];
      rooms.forEach(room => {
        const corridor = isCorridor(room);
        const roomHeight = corridor ? 0.3 : 1.5;
        
        const shape = new THREE.Shape();
        const pts = room.points.map(p => ({x:(p.x - localOffsetX) * localScale, y:(p.y - localOffsetY) * localScale}));
        if (pts.length < 3) return;
        shape.moveTo(pts[0].x, pts[0].y);
        pts.slice(1).forEach(p => shape.lineTo(p.x, p.y));
        shape.closePath();
        
        const geo = new THREE.ExtrudeGeometry(shape, {depth: roomHeight, bevelEnabled: false});
        const color = corridor ? 0xe2e8f0 : getRoomColor(room.info);
        const mat = new THREE.MeshStandardMaterial({
          color: color, side: THREE.DoubleSide,
          transparent: true, opacity: corridor ? 0.4 : 0.95
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = !corridor;
        mesh.receiveShadow = true;
        mesh.userData = { room, originalColor: color, targetZ: 0, isCorridor: corridor, floorNum };
        mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({color: corridor ? 0x94a3b8 : 0x475569})));
        
        // æ ‡ç­¾ï¼ˆä»…åœ¨å•å±‚è§†å›¾æ˜¾ç¤ºï¼‰
        if (showLabels && room.info && room.info.roomNumber && room.info.roomName && !corridor) {
          const lx = (room.center.x - localOffsetX) * localScale;
          const ly = (room.center.y - localOffsetY) * localScale;
          // æ£€æŸ¥åæ ‡æ˜¯å¦æœ‰æ•ˆ
          if (!isNaN(lx) && !isNaN(ly) && isFinite(lx) && isFinite(ly)) {
            const labelDiv = document.createElement('div');
            labelDiv.className = 'room-label';
            labelDiv.dataset.floor = floorNum;
            const icon = getRoomIcon(room.info);
            labelDiv.innerHTML = `<span class="icon">${icon}</span><div class="content"><span class="num">${room.info.roomNumber}</span><span class="name">${room.info.roomName}</span></div>`;
            const label = new CSS2DObject(labelDiv);
            label.position.set(lx, ly, roomHeight + 0.5);
            mesh.add(label);
          }
        }
        
        group.add(mesh);
        meshes.push(mesh);
      });
      
      group.position.z = zOffset;
      return { group, meshes };
    }

    // æ¸…é™¤æ‰€æœ‰æ¥¼å±‚
    function clearAllFloors() {
      Object.values(floorGroups).forEach(fg => {
        fg.meshes.forEach(m => {
          m.children.forEach(child => {
            if (child.isCSS2DObject && child.element) child.element.remove();
          });
        });
        scene.remove(fg.group);
      });
      floorGroups = {};
      roomMeshes = [];
      hoveredMesh = null;
      selectedMesh = null;
    }

    // æ˜¾ç¤ºå…¨éƒ¨æ¥¼å±‚ï¼ˆå †å è§†å›¾ï¼‰
    async function showAllFloors() {
      clearAllFloors();
      document.getElementById('loading').style.display = 'flex';
      document.getElementById('loading').querySelector('p').textContent = 'æ­£åœ¨åŠ è½½å…¨éƒ¨æ¥¼å±‚...';
      
      let totalRooms = 0, totalInfo = 0;
      
      for (let i = 1; i <= FLOOR_COUNT; i++) {
        if (!allFloorsData[i]) {
          allFloorsData[i] = await parseFloorDXF(i);
        }
        const rooms = allFloorsData[i];
        const zOffset = (i - 1) * FLOOR_HEIGHT;
        // å…¨æ™¯æ¨¡å¼ä¸æ˜¾ç¤ºæ ‡ç­¾
        const { group, meshes } = createFloorMeshes(rooms, i, zOffset, false);
        floorGroups[i] = { group, meshes };
        scene.add(group);
        roomMeshes.push(...meshes);
        totalRooms += rooms.length;
        totalInfo += rooms.filter(r => r.info).length;
      }
      
      // æ„å»ºæœç´¢ç´¢å¼•ï¼ˆç›´æ¥ä»meshè·å–roomå¼•ç”¨ï¼‰
      allRoomsIndex = [];
      for (let i = 1; i <= FLOOR_COUNT; i++) {
        const meshes = floorGroups[i].meshes;
        meshes.forEach(mesh => {
          const room = mesh.userData.room;
          if (room && room.info) {
            allRoomsIndex.push({ floorNum: i, room, mesh });
          }
        });
      }
      
      document.getElementById('room-count').textContent = `${totalRooms} æˆ¿é—´`;
      document.getElementById('info-count').textContent = '';
      document.getElementById('floor-indicator').textContent = 'ALL';
      document.getElementById('loading').style.display = 'none';
      
      // è°ƒæ•´ç›¸æœºä½ç½®ä»¥æŸ¥çœ‹æ•´æ ‹å»ºç­‘ï¼ˆä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„è§’åº¦ï¼‰
      camera.position.set(-0.4, -70.3, 60.3);
      controls.target.set(-0.7, 0, 25);
      controls.update();
    }

    // æ˜¾ç¤ºå•ä¸ªæ¥¼å±‚
    async function showSingleFloor(floorNum) {
      clearAllFloors();
      document.getElementById('loading').style.display = 'flex';
      document.getElementById('loading').querySelector('p').textContent = `æ­£åœ¨åŠ è½½ ${FLOOR_NAMES[floorNum]}...`;
      
      if (!allFloorsData[floorNum]) {
        allFloorsData[floorNum] = await parseFloorDXF(floorNum);
      }
      const rooms = allFloorsData[floorNum];
      const { group, meshes } = createFloorMeshes(rooms, floorNum, 0);
      floorGroups[floorNum] = { group, meshes };
      scene.add(group);
      roomMeshes.push(...meshes);
      
      // æ˜¾ç¤ºæ ‡ç­¾
      meshes.forEach(m => {
        m.children.forEach(child => {
          if (child.isCSS2DObject && child.element) {
            child.element.style.display = '';
          }
        });
      });
      
      // æ„å»ºæœç´¢ç´¢å¼•ï¼ˆå•å±‚ï¼‰
      allRoomsIndex = [];
      const floorMeshes = floorGroups[floorNum].meshes;
      rooms.forEach((room, idx) => {
        if (room.info) {
          allRoomsIndex.push({ floorNum, room, mesh: floorMeshes[idx] });
        }
      });
      
      document.getElementById('room-count').textContent = `${rooms.length} æˆ¿é—´`;
      document.getElementById('info-count').textContent = '';
      document.getElementById('floor-indicator').textContent = FLOOR_NAMES[floorNum];
      document.getElementById('loading').style.display = 'none';
      
      // è°ƒæ•´ç›¸æœºä½ç½®ï¼ˆä½¿ç”¨ç”¨æˆ·æŒ‡å®šçš„è§’åº¦ï¼‰
      camera.position.set(0.3, -34.7, 29.5);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    // åˆ‡æ¢è§†å›¾ï¼ˆå¸¦åŠ¨ç”»è¿‡æ¸¡ï¼‰
    async function switchView(view) {
      const prevView = currentView;
      currentView = view;
      document.getElementById('selected-info').classList.add('hidden');
      if (selectedMesh) {
        selectedMesh.material.color.setHex(selectedMesh.userData.originalColor);
        if (selectedMesh.material.emissive) selectedMesh.material.emissive.setHex(0x000000);
        selectedMesh.userData.targetZ = 0;
        selectedMesh = null;
      }
      
      const floorNum = view === 'all' ? null : parseInt(view);
      const prevFloorNum = prevView === 'all' ? null : parseInt(prevView);
      
      // å®šä¹‰ç›¸æœºç›®æ ‡ä½ç½®
      const allCamPos = new THREE.Vector3(-0.4, -70.3, 60.3);
      const allTarget = new THREE.Vector3(-0.7, 0, 25);
      const singleCamPos = new THREE.Vector3(0.3, -34.7, 29.5);
      const singleTarget = new THREE.Vector3(0, 0, 0);
      
      if (prevView === 'all' && floorNum) {
        // ALL -> å•å±‚ï¼šæ·¡å‡ºå…¶ä»–æ¥¼å±‚ï¼Œç›¸æœºç§»åŠ¨åˆ°è¯¥æ¥¼å±‚
        const targetZ = (floorNum - 1) * FLOOR_HEIGHT;
        cameraTargetLookAt = new THREE.Vector3(0, 0, targetZ);
        cameraTargetPos = new THREE.Vector3(0.3, -34.7, targetZ + 29.5);
        
        // æ·¡å‡ºå…¶ä»–æ¥¼å±‚
        for (let i = 1; i <= FLOOR_COUNT; i++) {
          if (i !== floorNum && floorGroups[i]) {
            fadeAnimations.push({ meshes: floorGroups[i].meshes, targetOpacity: 0 });
          }
        }
        
        setTimeout(async () => {
          await showSingleFloor(floorNum);
          // æ·¡å…¥å½“å‰æ¥¼å±‚
          if (floorGroups[floorNum]) {
            floorGroups[floorNum].meshes.forEach(m => { m.material.opacity = 0; m.visible = true; });
            fadeAnimations.push({ meshes: floorGroups[floorNum].meshes, targetOpacity: 0.95 });
          }
        }, 600);
        
      } else if (prevFloorNum && view === 'all') {
        // å•å±‚ -> ALLï¼šæ·¡å‡ºå½“å‰æ¥¼å±‚ï¼Œç¼©å°è§†è§’ï¼Œæ·¡å…¥å…¨éƒ¨æ¥¼å±‚
        if (floorGroups[prevFloorNum]) {
          fadeAnimations.push({ meshes: floorGroups[prevFloorNum].meshes, targetOpacity: 0 });
        }
        cameraTargetPos = allCamPos.clone();
        cameraTargetLookAt = allTarget.clone();
        
        setTimeout(async () => {
          await showAllFloors();
          // æ·¡å…¥æ‰€æœ‰æ¥¼å±‚
          for (let i = 1; i <= FLOOR_COUNT; i++) {
            if (floorGroups[i]) {
              floorGroups[i].meshes.forEach(m => { m.material.opacity = 0; m.visible = true; });
              fadeAnimations.push({ meshes: floorGroups[i].meshes, targetOpacity: 0.95 });
            }
          }
        }, 500);
        
      } else if (prevFloorNum && floorNum && prevFloorNum !== floorNum) {
        // æ¥¼å±‚ -> æ¥¼å±‚ï¼šæ·¡å‡ºå½“å‰æ¥¼å±‚ï¼Œç¼©å°ï¼Œæ·¡å…¥ç›®æ ‡æ¥¼å±‚
        if (floorGroups[prevFloorNum]) {
          fadeAnimations.push({ meshes: floorGroups[prevFloorNum].meshes, targetOpacity: 0 });
        }
        cameraTargetPos = new THREE.Vector3(0.3, -50, 45);
        cameraTargetLookAt = new THREE.Vector3(0, 0, 15);
        
        setTimeout(async () => {
          await showSingleFloor(floorNum);
          // æ·¡å…¥ç›®æ ‡æ¥¼å±‚
          if (floorGroups[floorNum]) {
            floorGroups[floorNum].meshes.forEach(m => { m.material.opacity = 0; m.visible = true; });
            fadeAnimations.push({ meshes: floorGroups[floorNum].meshes, targetOpacity: 0.95 });
          }
        }, 400);
        
      } else {
        // ç›´æ¥åˆ‡æ¢
        if (view === 'all') {
          await showAllFloors();
        } else {
          await showSingleFloor(floorNum);
        }
      }
      
      document.getElementById('floor-indicator').textContent = view === 'all' ? 'ALL' : FLOOR_NAMES[floorNum];
    }

    async function init() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8fafc);
      camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 80);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);
      
      labelRenderer = new CSS2DRenderer();
      labelRenderer.setSize(container.clientWidth, container.clientHeight);
      labelRenderer.domElement.style.position = 'absolute';
      labelRenderer.domElement.style.top = '0';
      labelRenderer.domElement.style.pointerEvents = 'none';
      container.appendChild(labelRenderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(20, 20, 40); dirLight.castShadow = true;
      scene.add(dirLight);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; 
      controls.minDistance = 10; 
      controls.maxDistance = 300;
      // é¼ æ ‡æŒ‰é”®æ˜ å°„ï¼šå·¦é”®å¹³ç§»ï¼Œä¸­é”®æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾
      controls.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.ROTATE,
        RIGHT: THREE.MOUSE.DOLLY
      };
      controls.panSpeed = 1.5;
      controls.rotateSpeed = 0.8;

      const tooltip = document.getElementById('tooltip'), tooltipHeader = document.getElementById('tooltip-header'), tooltipBody = document.getElementById('tooltip-body');

      function updateTooltip(room, floorNum, x, y) {
        if (!room) { tooltip.classList.add('hidden'); return; }
        const info = room.info, name = info?.roomName || `æˆ¿é—´ ${room.id+1}`, num = info?.roomNumber || '';
        const floorLabel = currentView === 'all' && floorNum ? `<span class="text-amber-600 mr-2">${FLOOR_NAMES[floorNum]}</span>` : '';
        tooltipHeader.innerHTML = floorLabel + (num ? `<span class="text-blue-600 mr-2">${num}</span>${name}` : name);
        tooltipBody.innerHTML = info ? `
          ${info.roomType ? `<div class="flex justify-between"><span class="text-slate-500">å±æ€§:</span><span class="text-slate-700">${info.roomType}</span></div>` : ''}
          ${info.usableArea ? `<div class="flex justify-between"><span class="text-slate-500">é¢ç§¯:</span><span class="text-slate-700">${info.usableArea}</span></div>` : ''}
          ${info.users ? `<div class="flex justify-between"><span class="text-slate-500">äººå‘˜:</span><span class="text-slate-700">${info.users}</span></div>` : ''}
        ` : '<div class="text-slate-400">æš‚æ— è¯¦ç»†ä¿¡æ¯</div>';
        tooltip.style.left = (x+15)+'px'; tooltip.style.top = (y+15)+'px';
        tooltip.classList.remove('hidden');
      }

      function updateSelected(room) {
        const panel = document.getElementById('selected-info');
        if (!room) { panel.classList.add('hidden'); return; }
        const info = room.info;
        document.getElementById('selected-name').textContent = info?.roomNumber ? `${info.roomNumber} - ${info?.roomName||''}` : (info?.roomName || `æˆ¿é—´ ${room.id+1}`);
        document.getElementById('selected-details').innerHTML = info ? `
          ${info.roomType ? `<div>å±æ€§: ${info.roomType}</div>` : ''}${info.usableArea ? `<div>é¢ç§¯: ${info.usableArea}</div>` : ''}${info.users ? `<div>äººå‘˜: ${info.users}</div>` : ''}
        ` : '<div>æš‚æ— è¯¦ç»†ä¿¡æ¯</div>';
        panel.classList.remove('hidden');
      }

      renderer.domElement.addEventListener('mousemove', e => {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX-rect.left)/rect.width)*2-1;
        mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(roomMeshes);
        if (intersects.length) {
          const mesh = intersects[0].object;
          if (mesh !== hoveredMesh) {
            if (hoveredMesh && hoveredMesh !== selectedMesh) { 
              hoveredMesh.material.color.setHex(hoveredMesh.userData.originalColor); 
              hoveredMesh.userData.targetZ = 0; 
            }
            hoveredMesh = mesh;
            if (mesh !== selectedMesh) { 
              mesh.material.color.setHex(0x3b82f6); 
              mesh.userData.targetZ = 0.4; 
            }
          }
          updateTooltip(mesh.userData.room, mesh.userData.floorNum, e.clientX, e.clientY);
          renderer.domElement.style.cursor = 'pointer';
        } else {
          if (hoveredMesh && hoveredMesh !== selectedMesh) { 
            hoveredMesh.material.color.setHex(hoveredMesh.userData.originalColor); 
            hoveredMesh.userData.targetZ = 0; 
          }
          hoveredMesh = null; updateTooltip(null); renderer.domElement.style.cursor = 'default';
        }
      });

      renderer.domElement.addEventListener('click', () => {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(roomMeshes);
        if (intersects.length) {
          const mesh = intersects[0].object;
          selectRoom(mesh); // é¼ æ ‡ç‚¹å‡»åªé€‰ä¸­ï¼Œä¸ç§»åŠ¨ç›¸æœº
        } else {
          if (selectedMesh && selectedMesh.material) {
            selectedMesh.material.color.setHex(selectedMesh.userData.originalColor);
            if (selectedMesh.material.emissive) selectedMesh.material.emissive.setHex(0x000000);
            selectedMesh.userData.targetZ = 0;
            selectedMesh = null;
          }
          updateSelected(null);
        }
      });

      // æ¥¼å±‚åˆ‡æ¢æŒ‰é’®
      document.querySelectorAll('.floor-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const floor = btn.dataset.floor;
          if (floor === String(currentView)) return;
          
          document.querySelectorAll('.floor-btn').forEach(b => {
            b.classList.remove('active', 'bg-blue-600', 'text-white');
            b.classList.add('bg-white/90', 'text-slate-600');
          });
          btn.classList.add('active', 'bg-blue-600', 'text-white');
          btn.classList.remove('bg-white/90', 'text-slate-600');
          
          await switchView(floor);
        });
      });

      // æœç´¢åŠŸèƒ½
      const searchInput = document.getElementById('search-input');
      const searchResults = document.getElementById('search-results');
      
      function performSearch(query) {
        if (!query.trim()) {
          searchResults.classList.add('hidden');
          return;
        }
        const q = query.toLowerCase();
        const results = [];
        allRoomsIndex.forEach((item, idx) => {
          const info = item.room.info;
          if ((info.roomNumber && info.roomNumber.toLowerCase().includes(q)) ||
              (info.roomName && info.roomName.toLowerCase().includes(q)) ||
              (info.roomType && info.roomType.toLowerCase().includes(q))) {
            results.push({ ...item, idx });
          }
        });
        const limited = results.slice(0, 10);
        
        if (limited.length === 0) {
          searchResults.innerHTML = '<div class="p-4 text-center text-slate-400">æœªæ‰¾åˆ°åŒ¹é…çš„æˆ¿é—´</div>';
        } else {
          searchResults.innerHTML = limited.map(item => {
            const info = item.room.info;
            const icon = getRoomIcon(info);
            return `<div class="search-item p-3 hover:bg-blue-50 cursor-pointer border-b border-slate-100 last:border-0 flex items-center gap-3" data-index="${item.idx}">
              <span class="text-xl">${icon}</span>
              <div class="flex-1">
                <div class="font-bold text-slate-800">${info.roomNumber || ''} ${info.roomName || ''}</div>
                <div class="text-xs text-slate-500">${FLOOR_NAMES[item.floorNum]} Â· ${info.roomType || ''}</div>
              </div>
            </div>`;
          }).join('');
        }
        searchResults.classList.remove('hidden');
      }
      
      searchInput.addEventListener('input', e => performSearch(e.target.value));
      searchInput.addEventListener('focus', () => { if (searchInput.value) performSearch(searchInput.value); });
      
      // é€‰ä¸­æˆ¿é—´ï¼ˆä¸ç§»åŠ¨ç›¸æœºï¼‰
      function selectRoom(mesh) {
        if (!mesh || !mesh.material) return;
        
        // å–æ¶ˆä¹‹å‰çš„é€‰ä¸­
        if (selectedMesh && selectedMesh !== mesh && selectedMesh.material) {
          selectedMesh.material.color.setHex(selectedMesh.userData.originalColor);
          if (selectedMesh.material.emissive) selectedMesh.material.emissive.setHex(0x000000);
          selectedMesh.userData.targetZ = 0;
        }
        
        // é€‰ä¸­æ–°æˆ¿é—´
        selectedMesh = mesh;
        selectedMesh.material.color.setHex(0xf59e0b);
        if (selectedMesh.material.emissive) selectedMesh.material.emissive.setHex(0x663300);
        selectedMesh.userData.targetZ = 0.8;
        updateSelected(mesh.userData.room);
      }
      
      // èšç„¦åˆ°æŒ‡å®šæˆ¿é—´ï¼ˆå¸¦ç›¸æœºåŠ¨ç”»ï¼Œç”¨äºæœç´¢ï¼‰
      function focusOnRoom(mesh) {
        if (!mesh || !mesh.material) return;
        
        selectRoom(mesh);
        
        // è®¡ç®—æˆ¿é—´ä¸­å¿ƒçš„ä¸–ç•Œåæ ‡
        const box = new THREE.Box3().setFromObject(mesh);
        const center = box.getCenter(new THREE.Vector3());
        
        // è®¡ç®—å½“å‰ç›¸æœºåˆ°ç›®æ ‡çš„æ–¹å‘ï¼ˆä¿æŒè§‚å¯Ÿè§’åº¦ï¼‰
        const camToTarget = controls.target.clone().sub(camera.position);
        const currentDir = camToTarget.normalize();
        const focusDist = 35; // èšç„¦æ—¶çš„å›ºå®šè·ç¦»
        
        // æ–°çš„ç›®æ ‡ç‚¹ = æˆ¿é—´ä¸­å¿ƒ
        cameraTargetLookAt = center.clone();
        // æ–°çš„ç›¸æœºä½ç½® = æˆ¿é—´ä¸­å¿ƒ - è§‚å¯Ÿæ–¹å‘ * è·ç¦»
        cameraTargetPos = center.clone().sub(currentDir.clone().multiplyScalar(focusDist));
      }
      
      // ç‚¹å‡»æœç´¢ç»“æœ
      searchResults.addEventListener('click', e => {
        const item = e.target.closest('.search-item');
        if (!item) return;
        
        const idx = parseInt(item.dataset.index);
        const searchItem = allRoomsIndex[idx];
        if (!searchItem || !searchItem.mesh) return;
        
        focusOnRoom(searchItem.mesh);
        
        searchResults.classList.add('hidden');
        searchInput.value = '';
      });
      
      // ç‚¹å‡»å¤–éƒ¨å…³é—­æœç´¢ç»“æœ
      document.addEventListener('click', e => {
        if (!e.target.closest('#search-input') && !e.target.closest('#search-results')) {
          searchResults.classList.add('hidden');
        }
      });
      
      // å…³é—­é€‰ä¸­é¢æ¿
      document.getElementById('close-selected').addEventListener('click', () => {
        if (selectedMesh && selectedMesh.material) {
          selectedMesh.material.color.setHex(selectedMesh.userData.originalColor);
          if (selectedMesh.material.emissive) selectedMesh.material.emissive.setHex(0x000000);
          selectedMesh.userData.targetZ = 0;
          selectedMesh = null;
        }
        document.getElementById('selected-info').classList.add('hidden');
      });

      // æ ¹æ® URL å‚æ•°è®¾ç½®åˆå§‹è§†å›¾ ?view=all|1|2|3|4|5|6
      const params = new URLSearchParams(window.location.search);
      const viewParam = params.get('view');
      let initialView = 'all';
      if (viewParam && (viewParam === 'all' || (parseInt(viewParam) >= 1 && parseInt(viewParam) <= FLOOR_COUNT))) {
        initialView = viewParam;
      }

      // åŒæ­¥å³ä¾§æ¥¼å±‚æŒ‰é’®æ¿€æ´»çŠ¶æ€
      const btns = document.querySelectorAll('.floor-btn');
      btns.forEach(btn => {
        const f = btn.dataset.floor;
        btn.classList.remove('active', 'bg-blue-600', 'text-white');
        btn.classList.add('bg-white/90', 'text-slate-600');
        if (f === String(initialView)) {
          btn.classList.add('active', 'bg-blue-600', 'text-white');
          btn.classList.remove('bg-white/90', 'text-slate-600');
        }
      });

      // è®¾ç½®å½“å‰è§†å›¾å¹¶åŠ è½½å¯¹åº”æ¥¼å±‚ï¼ˆé¦–æ¬¡åŠ è½½ä¸éœ€è¦è¿‡æ¸¡åŠ¨ç”»ï¼Œé¿å…å…¶ä»–æ¥¼å±‚æ®‹ç•™ï¼‰
      currentView = initialView;
      document.getElementById('selected-info').classList.add('hidden');
      if (initialView === 'all') {
        await showAllFloors();
      } else {
        await showSingleFloor(parseInt(initialView));
      }
      document.getElementById('floor-indicator').textContent = initialView === 'all' ? 'ALL' : FLOOR_NAMES[parseInt(initialView)];

      function animate() {
        requestAnimationFrame(animate);
        
        // æˆ¿é—´æŠ¬å‡åŠ¨ç”»
        roomMeshes.forEach(m => {
          m.position.z += (m.userData.targetZ - m.position.z) * 0.12;
        });
        
        // ç›¸æœºå¹³æ»‘ç§»åŠ¨åŠ¨ç”»
        if (cameraTargetPos) {
          camera.position.lerp(cameraTargetPos, cameraAnimSpeed);
          if (camera.position.distanceTo(cameraTargetPos) < 0.5) {
            cameraTargetPos = null;
          }
        }
        if (cameraTargetLookAt) {
          controls.target.lerp(cameraTargetLookAt, cameraAnimSpeed);
          if (controls.target.distanceTo(cameraTargetLookAt) < 0.5) {
            cameraTargetLookAt = null;
          }
        }
        
        // é€æ˜åº¦åŠ¨ç”»
        fadeAnimations = fadeAnimations.filter(anim => {
          let done = true;
          anim.meshes.forEach(m => {
            const current = m.material.opacity;
            const diff = anim.targetOpacity - current;
            if (Math.abs(diff) > 0.01) {
              m.material.opacity += diff * 0.15;
              done = false;
            } else {
              m.material.opacity = anim.targetOpacity;
            }
            // å®Œå…¨é€æ˜æ—¶éšè—
            m.visible = m.material.opacity > 0.01;
          });
          return !done;
        });
        
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
        
        // æ›´æ–°ç›¸æœºè°ƒè¯•é¢æ¿
        const p = camera.position, t = controls.target;
        document.getElementById('cam-pos').textContent = `${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
        document.getElementById('cam-target').textContent = `${t.x.toFixed(1)}, ${t.y.toFixed(1)}, ${t.z.toFixed(1)}`;
        document.getElementById('cam-dist').textContent = p.distanceTo(t).toFixed(1);
      }

      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth/container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
        labelRenderer.setSize(container.clientWidth, container.clientHeight);
      });

      // å¯åŠ¨æ¸²æŸ“å¾ªç¯
      animate();
    }

    init().catch(err => {
      document.getElementById('loading').innerHTML = `<div class="text-center"><div class="text-6xl mb-4">âŒ</div><p class="text-red-600">åŠ è½½å¤±è´¥: ${err.message}</p></div>`;
    });
  </script>
</body>
</html>
